# 开环切入电流环偶发过流问题分析

## 问题描述

从开环模式（OPEN_LOOP）切换到电流环模式（CURRENT）时，**有时候会触发过流保护**，但并非每次都发生。

---

## 根本原因分析

### 1. **开环与闭环的角度不连续**

#### 开环模式运行状态
```c
void foc_open_loop_run(foc_t *handle, float speed_rpm, float voltage_q)
{
    float delta_angle = 2.0f * M_PI * MOTOR_POLE_PAIR * 
                        (speed_rpm / 60.0f) * 0.0001f;
    
    handle->open_loop_angle_el += delta_angle;  // 累加开环角度
    
    dq_t u_dq = {.d = 0.0f, .q = voltage_q};
    alphabeta_t alpha_beta = ipark_transform(u_dq, handle->open_loop_angle_el);
    // ...
}
```

- 开环使用 `handle->open_loop_angle_el` 作为电角度
- 这个角度是**虚拟的旋转磁场角度**，与实际转子位置可能存在偏差

#### 电流环模式运行状态
```c
void foc_current_closed_loop_run(foc_t *handle, dq_t i_dq, float angle_el)
{
    handle->v_d_out = pid_calculate(handle->pid_id, handle->target_id, i_dq.d);
    handle->v_q_out = pid_calculate(handle->pid_iq, handle->target_iq, i_dq.q);

    alphabeta_t v_alphabeta = ipark_transform(
        (dq_t){.d = handle->v_d_out, .q = handle->v_q_out}, 
        angle_el  // 使用编码器实际角度
    );
    // ...
}
```

- 电流环使用 `angle_el`（来自编码器的实际电角度）
- 这个角度是**真实转子位置**

#### 角度突变问题

| 时刻 | 开环角度 | 实际角度 | 角度差 |
|------|----------|----------|--------|
| 切换前 | `open_loop_angle_el` | `mech_angle × 7 - offset` | 可能很大 |
| 切换后 | 不再使用 | `mech_angle × 7 - offset` | **突变** |

**关键问题**：
- 开环运行时，电机可能因负载、摩擦等原因**跟不上旋转磁场**
- 开环角度 ≠ 实际角度，存在**相位差**
- 切换瞬间，控制角度从虚拟角度跳变到真实角度
- **角度突变 → 电压矢量方向突变 → 电流冲击**

---

### 2. **PID积分项为零导致的电压跌落**

#### 切换时的PID状态
```c
static void enter_current(void)
{
    /* 复位PID并设置目标电流 */
    pid_reset(&pid_id);  // ← 积分项清零
    pid_reset(&pid_iq);  // ← 积分项清零
    foc_handle.target_id = 0.0f;
    foc_handle.target_iq = 0.5f;
    ctrl_mode = CTRL_MODE_CURRENT;
}
```

**问题**：
- 开环时输出 `voltage_q = 1.0V`，维持电机旋转
- 切换到电流环时，PID积分项被清零
- 第一个控制周期：`v_q_out = Kp × error + 0`（积分项为0）
- 如果电流反馈接近目标值，误差小，**输出电压会远小于1V**
- 电压突然降低 → 电机减速 → 电流增大（负载转矩作用）

#### 电压输出对比

| 模式 | 输出电压 | 说明 |
|------|----------|------|
| 开环 | 固定 1.0V | 恒定输出 |
| 电流环（首周期） | `0.017 × error` | 积分项为0，输出很小 |
| 电流环（稳态） | `0.017 × error + integral` | 积分项补偿 |

---

### 3. **电流环PID参数响应速度不足**

```c
pid_init(&pid_id, 0.017f, 0.002826f, -U_DC / 4.0f, U_DC / 4.0f);
pid_init(&pid_iq, 0.017f, 0.002826f, -U_DC / 4.0f, U_DC / 4.0f);
```

- `Kp = 0.017`：比例系数较小
- `Ki = 0.002826`：积分系数很小
- 当电流突变时，PID需要**多个周期**才能建立足够的积分项
- 在此期间，如果负载较大，电流可能持续上升

---

### 4. **竞态条件（次要因素）**

```c
void motor_ctrl_switch_mode(void)
{
    switch (ctrl_mode)
    {
    case CTRL_MODE_OPEN_LOOP:
        enter_current();  // ← 主循环修改模式
        printf("Mode: CURRENT, Iq=0.5A\n");
        break;
    }
}
```

```c
static void motor_ctrl_callback(void)  // ← 10kHz中断
{
    if (ctrl_mode == CTRL_MODE_OPEN_LOOP)
    {
        foc_open_loop_run(&foc_handle, 200.0f, 1.0f);
        return;
    }
    // ...
    if (ctrl_mode == CTRL_MODE_CURRENT)
    {
        foc_current_closed_loop_run(&foc_handle, i_dq, angle_el);
    }
}
```

- 主循环和中断之间没有互斥保护
- 可能在切换瞬间，中断读取到中间状态
- 但这不是主要原因（因为单次异常不会导致过流）

---

## 为什么"有时候"过流？

### 偶发性的原因

| 因素 | 影响 |
|------|------|
| **按键时刻的相位差** | 如果开环角度与实际角度相差90°，电压矢量会垂直于期望方向，产生最大冲击 |
| **电机转速** | 转速越高，反电动势越大，角度突变时的电流冲击越大 |
| **负载状态** | 负载越大，开环时的相位滞后越严重 |
| **电流反馈值** | 如果切换时实际电流已经较大，再叠加冲击电流就会过流 |

### 最坏情况组合
```
开环相位滞后60° + 转速200RPM + 负载0.3A + 切换瞬间角度突变
→ 电流冲击 1.5A + 原有电流 0.3A = 1.8A
→ 如果过流阈值是 2A，就会触发保护
```

---

## 解决方案

### 方案一：角度连续性切换（推荐）

```c
static void enter_current(void)
{
    /* 1. 使用开环角度初始化闭环角度（保持连续性） */
    // 不需要修改，因为闭环会自动使用编码器角度
    
    /* 2. 使用开环电压初始化PID积分项 */
    pid_reset(&pid_id);
    pid_reset(&pid_iq);
    
    // 预填充积分项，使首次输出接近开环电压
    pid_iq.integral = 1.0f;  // 开环时的 voltage_q
    pid_iq.out = 1.0f;
    
    foc_handle.target_id = 0.0f;
    foc_handle.target_iq = 0.5f;
    ctrl_mode = CTRL_MODE_CURRENT;
}
```

**原理**：
- 让电流环的初始输出电压 ≈ 开环电压
- 避免电压突变
- PID从合理的初值开始调节

---

### 方案二：软切换过渡（最佳）

```c
static volatile uint16_t transition_counter = 0;
#define TRANSITION_CYCLES 100  // 10ms过渡时间

static void enter_current(void)
{
    pid_reset(&pid_id);
    pid_reset(&pid_iq);
    
    // 预填充积分项
    pid_iq.integral = 1.0f;
    pid_iq.out = 1.0f;
    
    foc_handle.target_id = 0.0f;
    foc_handle.target_iq = 0.1f;  // 先设置小电流
    
    transition_counter = TRANSITION_CYCLES;
    ctrl_mode = CTRL_MODE_CURRENT;
}

static void motor_ctrl_callback(void)
{
    // ... 其他代码 ...
    
    if (ctrl_mode == CTRL_MODE_CURRENT)
    {
        /* 过渡期间逐渐增加目标电流 */
        if (transition_counter > 0)
        {
            transition_counter--;
            float ratio = (float)(TRANSITION_CYCLES - transition_counter) / TRANSITION_CYCLES;
            foc_handle.target_iq = 0.1f + ratio * 0.4f;  // 0.1A → 0.5A
        }
        
        foc_current_closed_loop_run(&foc_handle, i_dq, angle_el);
    }
}
```

---

### 方案三：降低开环转速（临时方案）

```c
case CTRL_MODE_OPEN_LOOP:
    foc_open_loop_run(&foc_handle, 100.0f, 0.5f);  // 降低转速和电压
    return;
```

- 降低开环转速，减小相位滞后
- 降低开环电压，减小切换时的电流冲击
- 但会影响开环性能

---

### 方案四：增加过流阈值（不推荐）

- 治标不治本
- 可能掩盖真实的过流故障

---

## 推荐实施方案

### 组合方案：积分预填充 + 软切换

```c
static void enter_current(void)
{
    /* 复位PID */
    pid_reset(&pid_id);
    pid_reset(&pid_iq);
    
    /* 预填充Iq积分项，使初始输出接近开环电压 */
    pid_iq.integral = 1.0f;  // 开环 voltage_q
    pid_iq.out = 1.0f;
    
    /* 目标电流从小开始 */
    foc_handle.target_id = 0.0f;
    foc_handle.target_iq = 0.2f;  // 先设置较小值
    
    ctrl_mode = CTRL_MODE_CURRENT;
}
```

然后在主循环中逐渐增加目标电流：
```c
void motor_ctrl_switch_mode(void)
{
    case CTRL_MODE_OPEN_LOOP:
        enter_current();
        printf("Mode: CURRENT, Iq=0.2A→0.5A\n");
        
        /* 延迟增加目标电流 */
        HAL_Delay(50);  // 等待50ms
        foc_handle.target_iq = 0.5f;
        break;
}
```

---

## 总结

| 问题 | 根本原因 | 解决方法 |
|------|----------|----------|
| 角度不连续 | 开环虚拟角度 ≠ 实际角度 | 无法完全避免，但可通过软切换缓解 |
| 电压突变 | PID积分项清零 | **预填充积分项** |
| 响应不足 | PID参数偏小 | 增大Kp/Ki（需重新整定）|
| 电流冲击 | 目标电流突变 | **软切换，逐渐增加目标** |

**最简单有效的方案**：
1. 预填充 `pid_iq.integral = 1.0f`
2. 初始目标电流设为 `0.2A`
3. 延迟50ms后增加到 `0.5A`
