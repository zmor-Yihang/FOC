---

# STM32 按键驱动：从“死等”到“非阻塞”

在嵌入式开发中，按键驱动的写法直接决定了系统的实时性和稳定性。特别是在电机控制、多任务处理等场景下，**非阻塞（Non-blocking）** 写法是必须掌握的技能。

## 1. 传统阻塞式写法 (Blocking)

这是初学者最常用的写法，逻辑简单直观，但有致命缺陷。

### 代码逻辑
```c
uint8_t Key_Scan_Blocking(void)
{
    if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == 0) // 1. 检测按下
    {
        HAL_Delay(20); // 2. 【阻塞】死等20ms消抖
        if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == 0)
        {
            // 3. 【阻塞】死等按键松开，如果不松手，程序卡死在这里
            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == 0); 
            return 1;
        }
    }
    return 0;
}
```

### 缺点分析
*   **CPU 资源浪费**：`HAL_Delay` 和 `while` 循环期间，CPU 无法执行任何其他代码。
*   **系统风险**：如果用户按住按键不放，主循环被卡死。此时若电机发生过流、传感器需要读取或串口需要发送数据，**统统无法响应**，可能导致硬件损坏或系统崩溃。

---

## 2. 进阶非阻塞式写法 (Non-blocking) —— 推荐

这种写法将**状态记忆**封装在函数内部，利用**时间戳**代替延时，利用**逻辑运算**代替循环等待。

### 核心代码 (封装版)

```c
uint8_t Key_Scan_NonBlocking(void)
{
    /* 1. 静态变量：记忆历史状态 */
    static uint8_t Key_Old = 0;      // 保存上一次扫描时的按键状态
    static uint32_t Last_Time = 0;   // 保存上一次执行的时间
    
    uint8_t Key_Value = 0;           // 当前物理状态
    uint8_t Key_Down = 0;            // 最终返回的触发信号

    /* 2. 时间戳消抖：代替 HAL_Delay */
    // 如果距离上次扫描不足 20ms，直接返回，CPU 去做别的事
    if (HAL_GetTick() - Last_Time < 20) return 0;
    
    Last_Time = HAL_GetTick(); // 更新时间

    /* 3. 读取物理状态 (假设低电平有效) */
    if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == GPIO_PIN_RESET)
        Key_Value = 1; // 逻辑值：按下
    else
        Key_Value = 0; // 逻辑值：松开

    /* 4. 边缘检测算法：代替 while 等待 */
    Key_Down = Key_Value & (Key_Value ^ Key_Old); 
    
    /* 5. 更新历史状态 */
    Key_Old = Key_Value;

    return Key_Down; // 仅在按下瞬间返回1，其余时间返回0
}
```

---

## 3. 关键技术点解析

### A. `static` (静态变量) 的妙用
在函数内部定义 `static` 变量，作用域仅限于该函数，但生命周期贯穿整个程序运行。
*   **普通变量**：函数结束，变量销毁；下次进来，一切重置。
*   **静态变量**：函数结束，变量值保留；下次进来，还能记得“上次按键是松开还是按下”。
*   **意义**：实现了“状态记忆”，让我们可以对比“前一刻”和“这一刻”的区别，从而去掉全局变量，提高代码封装性。

### B. `HAL_GetTick()` (时间戳消抖)
*   **原理**：利用系统滴答定时器获取当前时间（毫秒）。
*   **逻辑**：`当前时间 - 上次时间 < 20ms`。
*   **优势**：CPU 只是看一眼时间，没到时间就立马 `return` 去处理电机或串口，**耗时微秒级**，完全不阻塞主循环。

### C. `^` (异或) 与 `&` (与) —— 边缘检测的核心
这是不用 `while` 就能检测“按下瞬间”的数学魔法。

**公式**：`Key_Down = Key_Value & (Key_Value ^ Key_Old)`

假设：1 = 按下，0 = 松开。

| 场景 | 上次状态 (Key_Old) | 当前状态 (Key_Value) | 异或 (Value ^ Old)<br>“状态变了吗？” | 与运算 (Value & 异或)<br>“是变成按下吗？” | 结果 (Key_Down) |
| :--- | :---: | :---: | :---: | :---: | :---: |
| **平时** | 0 | 0 | 0 (没变) | 0 | **0** |
| **按下瞬间** | 0 | **1** | **1 (变了)** | 1 & 1 = **1** | **1 (触发!)** |
| **按住不放** | 1 | 1 | 0 (没变) | 1 & 0 = 0 | **0** |
| **松开瞬间** | 1 | 0 | 1 (变了) | 0 & 1 = 0 | **0** |

*   **异或 (`^`)**：相同为 0，不同为 1。它的作用是**检测变化**。只要当前状态和上次不一样，结果就是 1。
*   **与 (`&`)**：它的作用是**筛选**。我们只关心“变成按下（1）”的那次变化，不关心“变成松开（0）”的变化。
*   也就是说:上次为1，当前为1，说明按键按住不放，不触发。
*   上次为0，当前为1，说明按键按下瞬间，触发。
*   上次为1，当前为0，说明按键松开瞬间，不触发。
*   上次为0，当前为0，说明按键松开，不触发。

## 4. 总结对比

| 特性 | 阻塞式 (死等) | 非阻塞式 (状态机) |
| :--- | :--- | :--- |
| **CPU 占用** | 极高 (100% 空转) | 极低 (微秒级) |
| **多任务能力** | 差 (会卡死其他任务) | 强 (电机、通信照常运行) |
| **消抖方式** | `HAL_Delay` (延时) | `HAL_GetTick` (时间差) |
| **防连触方式** | `while` (死循环) | `^` (异或边缘检测) |
| **适用场景** | 简单的流水灯实验 | **电机控制、工程项目** |